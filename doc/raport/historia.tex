\section{Interfejs programu}
Na samym początku projektu, po wybraniu jego tematu, planowaliśmy stworzyć narzędzie obsługiwanie z linii komend do "kompilacji" plików tekstowych w diagramy UML. Mieliśmy również pomysł aby stworzyć moduł do LaTeXa służący do generacji diagramów, jednak szybko go zarzuciliśmy.
Z upływem czasu doszliśmy do wniosku, że łatwiejsze i wygodniejsze w użyciu będzie proste IDE umożliwiające zarówno tworzenie "kodu diagramu" jak i jego "kompilację". W pierwszej wersji okno apliakcji podzielone było na dwie części: część zawierającą kod i diagram. Diagram był statycznym obrazem generowanym na podstawie kodu w sąsiedniej części okna.
Kolejnym krokiem było umożliwienie użytkownikowi przeciąganie elementów na diagramie, który przestał być statyczny. Również okno z kodem otrzymało nową funkcjonalność jaką było podstawowe kolorowanie składni opartej o syntaktykę języka Python. Dodano również przycisk pozwalający na wygenerowanie diagramu w postaci rastrowej i zapisanie jej do pliku.
Następnie okno kodu zostało wypsażone w obsługę składni stworzonego przez nas języka. Kolejnym etapem było wykorzystanie architektury paneli do budowy wewnętrznej struktury okna oraz dodanie panelu obsługi błędów przetwarzania kodu. Dopiero w ostatniej fazie rozwoju aplikacji powstał moduł umożliwiający kompilację kodu do grafiki rastrowej z linii komend.
\section{Język opisu diagramów UML}
Od samego początku zakładaliśmy strukturę języka opartą o system klucz-wartość, którą utrzymaliśmy do końca trwania projektu. Naszym głównym celem było uzyskanie jak największej elastyczności języka, która miała umożliwiać definiowanie własnych elementów diagramów bez konieczności ingerencji w wewnętrzne struktury aplikacji. Zostało to uzyskane przez zastosowanie architektury modułów dołączanych dynamicznie przy uruchomieniu aplikacji. Użytkownik może stworzyć własne moduły, czyli elementy z których mogą składać się diagramy. Przez to możliwości robudowy naszego programu są praktycznie nieograniczone. W tym momencie użytkownik nie jest związany z notacją UML. Dopisując własne moduły można adaptować naszą aplikację np. do tworzenia diagramów BPMN.
W obecnej formie możliwa jest również walidacja kodu poddawanego kompilacji oraz zwrócenie wykrytych błędów wraz z numerami linii w których wystąpiły oraz prostą diagnostyką. Użytkownik w momencie kompilacji otrzymuje informację zwrotną na temat popełnionych błędów w konstrukcji kodu diagramu, które nie zawsze muszą być widoczne wprost.
\section{Sposób przyłączania relacji do obiektów}
Istotnym z punktu widzenia projektu architektury aplikacji zagadnieniem jest sposób w jaki relacje są podłączane do obiektów na diagramie. Na samym początku planowaliśmy by obiekty posiadały zbiór punktów na obrysie jego reprezentacji, do których relacja może zostać przyłączona. Takie rozwiązanie jednak stwarzało pewne problemy. Po pierwsze nie byliśmy w stanie z góry przewidzieć ile takich punktów na każdej krawędzi należy wyznaczyć aby wszystkie podłączone relacje wyglądały naturalnie. Natomiast zmiana zbioru tych punktów przy już istniejących dołączonych relacjach powodowałaby konieczność przeliczania ich położenia i przesuwania dołączonych relacji.
Rozwiązanie na które zdecydowaliśmy się ostatecznie jest nieporównywalnie prostsze zarówno ideowo jak i w implementacji. Mianowicie każdy obiekt ma jeden punkt, do którego przyłączane są wszystkie relacje, umieszczony w jego centrum. Takie rozwiązanie wymusiło na nas rozwiązanie problemu przesłaniania relacji przez reprezentację graficzną obiektu. Realizowane jest to poprzez znajdowanie przecięć (w geometrycznym znaczeniu) reprezentacji graficznej z relacją, a następnie przycinaniu linii ją symbolizującej.
\section{Integracja}
Na samym początku projektu nie było wyraźnego podziału funkcjonalności aplikacji pomiędzy członków zespołu. Każdy tworzył fragmenty które stanowiły odrębne byty, między którymi nie istniały ustalone interfejsy komunikacyjne. Jednak w momencie w którym byliśmy gotowi na zapewnienie podstawowej funkcjonalności pierwszej wersji aplikacji okazało się, że doskonale działające w odosobnieniu moduły nie mają wspólnych interfejsów. Co więcej stworzenie ich nie było trywialną sprawą. Pomimo tego powstała pierwsza, i choć bardzo niedoskonała, to działająca wersja aplikacji zapewniająca podstawową funkcjonalność.
Ponieważ wersja ta, ze względu na wspomniane problemy, była bardzo niedoskonała pod względem programistycznym, zdecydowaliśmy się na daleko idącą refaktoryzację kodu wraz z redefinicją kanałów komunikacyjnych. Dzięki temu krokowi powstała wersja aplikacji cechująca się pełną integracją modułów, jasno wyznaczonymi granicami funkcjonalności oraz jednoznacznie określonymi interfejsami między nimi. Także pojawiły się wyraźne podziały odpowiedzialności za poszczególne części aplikacji pomiędzy członków zespołu.
Od tej pory praca nad rozwojem aplikacji była o wiele łatwiejsza i przebiegała bez większych problemów. Każdy z programistów rozwijał kod, który bardzo dobrze znał z poprzedniego etapu rozwoju aplikacji, co znacznie przyspieszyło pracę i współpracę. Jednak co ważniejsze, od tego czasu aplikacja jest w pełni zintegrowana, a poprawki wprowadzane przez programistów nie zaburzały tej integralności. Praktycznie w każdej chwili aplikacja była gotowa do uruchomienia.
Wraz z tą zmianą, nadszedł czas wzajemnego testowania własnego kodu. Ponieważ aplikacja po wprowadzeniu zmian nie przestawała działać, wszyscy programiści dysponujący najnowszą wersją uruchamiając ją, chcąc czy nie chcąc, testowali kod nie tylko swój ale także innych członków zespołu. Od tej pory zaczęliśmy wzajemnie zgłaszać sobie zauważone usterki co drastycznie przyspieszyło tempo ich znajdowania.
